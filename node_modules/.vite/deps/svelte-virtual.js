import "./chunk-R3DD2IQX.js";
import {
  STYLE,
  add_locations,
  attribute_effect,
  bind_element_size,
  bind_this,
  check_target,
  each,
  if_block,
  legacy_api,
  prop,
  rest_props,
  set_style,
  snippet,
  validate_each_keys
} from "./chunk-U7FWKARU.js";
import {
  FILENAME,
  add_svelte_meta,
  append,
  child,
  comment,
  first_child,
  from_html,
  get,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  sibling,
  state,
  strict_equals,
  tag,
  template_effect,
  user_derived,
  user_effect
} from "./chunk-M37CY4BG.js";
import "./chunk-XVE2VFRE.js";
import "./chunk-ICXW7654.js";
import "./chunk-RGIOIEUU.js";

// node_modules/svelte-virtual/dist/utils.js
function scrollStop(refresh = 100) {
  let isScrolling;
  return (callback) => {
    clearTimeout(isScrolling);
    isScrolling = setTimeout(callback, refresh);
  };
}
function scrollSpeed(refresh = 200) {
  let lastScrollPosition = void 0;
  let isScrollingFast;
  return (speed, callback) => (scrollPosition) => {
    if (!lastScrollPosition) {
      lastScrollPosition = scrollPosition;
    } else {
      if (Math.abs(scrollPosition - lastScrollPosition) > speed) {
        callback.fast();
        if (isScrollingFast !== void 0) {
          clearTimeout(isScrollingFast);
          isScrollingFast = void 0;
        }
        isScrollingFast = setTimeout(() => {
          callback.slow();
          isScrollingFast = void 0;
        }, refresh);
      } else {
        if (isScrollingFast === void 0) {
          callback.slow();
        }
      }
      lastScrollPosition = scrollPosition;
    }
  };
}
var round = {
  ceil: (x, multiple) => Math.ceil(x / multiple) * multiple,
  floor: (x, multiple) => ~~(x / multiple) * multiple
};
var getGridIndices = (itemCount, itemHeight, height, columnCount, overScanColumn, scrollPosition) => {
  const indices = [];
  const startIndexTemp = round.floor(scrollPosition / itemHeight * columnCount, columnCount);
  const startIndexOverScan = startIndexTemp > overScanColumn ? startIndexTemp - overScanColumn : 0;
  const startIndex = startIndexTemp > 0 && startIndexOverScan >= 0 ? startIndexOverScan : startIndexTemp;
  const endIndexTemp = Math.min(itemCount, round.ceil((scrollPosition + height) / itemHeight * columnCount, columnCount));
  const endIndexOverScan = endIndexTemp + overScanColumn;
  const endIndex = endIndexOverScan < itemCount ? endIndexOverScan : itemCount;
  for (let i = startIndex; i < endIndex; i++)
    indices.push(i);
  return indices;
};
var getListIndices = (itemCount, itemSize, size, overScan, scrollPosition) => {
  const indices = [];
  const startIndexTemp = ~~(scrollPosition / itemSize);
  const startIndexOverScan = startIndexTemp > overScan ? startIndexTemp - overScan : 0;
  const startIndex = startIndexOverScan >= 0 ? startIndexOverScan : startIndexTemp;
  const endIndexTemp = Math.min(itemCount, ~~((scrollPosition + size) / itemSize));
  const endIndexOverScan = endIndexTemp + overScan;
  const endIndex = endIndexOverScan < itemCount ? endIndexOverScan : itemCount;
  for (let i = startIndex; i < endIndex; i++)
    indices.push(i);
  return indices;
};
var getRowIndex = (index, columnCount) => ~~(index / columnCount);

// node_modules/svelte-virtual/dist/grid/Grid.svelte
Grid[FILENAME] = "node_modules/svelte-virtual/dist/grid/Grid.svelte";
var scrollStop2 = scrollStop();
var _scrollSpeed = scrollSpeed();
var root_1 = add_locations(from_html(`<div><!></div>`), Grid[FILENAME], [[155, 2]]);
var root = add_locations(from_html(`<div><!> <div></div> <!></div>`), Grid[FILENAME], [[139, 0, [[160, 1]]]]);
function Grid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Grid);
  let width = prop($$props, "width", 3, "100%"), overScan = prop($$props, "overScan", 3, 1), marginLeft = prop($$props, "marginLeft", 3, 0), marginTop = prop($$props, "marginTop", 3, 0), scrollPosition = prop($$props, "scrollPosition", 15, 0), scrollBehavior = prop($$props, "scrollBehavior", 3, "auto"), getKey = prop($$props, "getKey", 3, (index) => index), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "itemCount",
      "itemHeight",
      "itemWidth",
      "height",
      "width",
      "overScan",
      "marginLeft",
      "marginTop",
      "scrollPosition",
      "scrollBehavior",
      "getKey",
      "columnCount",
      "onscroll",
      "header",
      "item",
      "placeholder",
      "footer"
    ],
    "rest"
  );
  let grid = tag(state(void 0), "grid");
  let _scrollPosition = tag(state(proxy(scrollPosition())), "_scrollPosition");
  let headerHeight = tag(state(0), "headerHeight");
  let offsetWidth = tag(state(0), "offsetWidth");
  let clientWidth = tag(state(0), "clientWidth");
  let indices = tag(state(proxy([])), "indices");
  let manualScroll = false;
  let isScrolling = false;
  let isScrollingFast = tag(state(false), "isScrollingFast");
  function scrollToIndex(index, behavior = scrollBehavior()) {
    scrollTo(getRowIndex(index, get(_columnCount)) * $$props.itemHeight + marginTop() + get(headerHeight), behavior);
  }
  function scrollToPosition(position, behavior = scrollBehavior()) {
    scrollTo(position, behavior);
  }
  const scrollTo = (top, behavior = scrollBehavior()) => {
    if (get(grid)) {
      manualScroll = true;
      get(grid).scrollTo({ top, behavior });
      manualScroll = false;
    }
  };
  const scrollToManual = (scrollPosition2) => {
    if (get(grid) && !manualScroll && !isScrolling) {
      manualScroll = true;
      get(grid).scrollTo({ top: scrollPosition2, behavior: scrollBehavior() });
      manualScroll = false;
    }
  };
  const getItemProps = (index) => {
    const rowIndex = getRowIndex(index, get(_columnCount));
    const columnIndex = index % get(_columnCount);
    return {
      rowIndex,
      columnIndex,
      style: `position: absolute; transform: translate3d(${columnIndex * $$props.itemWidth + marginLeft()}px, ${rowIndex * $$props.itemHeight + marginTop()}px, 0px); height: ${$$props.itemHeight}px; width: ${$$props.itemWidth}px; will-change: transform;`
    };
  };
  const onScroll = (event) => {
    isScrolling = true;
    if (!manualScroll) {
      set(_scrollPosition, Math.max(0, event.currentTarget.scrollTop - get(headerHeight)), true);
      scrollPosition(event.currentTarget.scrollTop);
      get(scrollSpeed2)(get(_scrollPosition));
    }
    scrollStop2(() => {
      isScrolling = false;
    });
  };
  let _columnCount = tag(
    user_derived(() => !$$props.columnCount ? Math.max(~~((get(offsetWidth) - marginLeft() - (get(offsetWidth) - get(clientWidth))) / $$props.itemWidth), 1) : $$props.columnCount),
    "_columnCount"
  );
  let innerHeight = tag(user_derived(() => round.ceil($$props.itemCount, get(_columnCount)) * $$props.itemHeight / get(_columnCount)), "innerHeight");
  let overScanColumn = tag(user_derived(() => get(_columnCount) * overScan()), "overScanColumn");
  user_effect(() => {
    if (get(offsetWidth) || get(_columnCount)) {
      set(indices, getGridIndices($$props.itemCount, $$props.itemHeight, $$props.height, get(_columnCount), get(overScanColumn), get(_scrollPosition)), true);
    }
  });
  user_effect(() => {
    if (get(grid)) {
      scrollToManual(scrollPosition());
    }
  });
  let scrollSpeed2 = tag(
    user_derived(() => _scrollSpeed($$props.height, {
      fast: () => {
        set(isScrollingFast, true);
      },
      slow: () => {
        set(isScrollingFast, false);
      }
    })),
    "scrollSpeed"
  );
  var $$exports = {
    get scrollToIndex() {
      return scrollToIndex;
    },
    get scrollToPosition() {
      return scrollToPosition;
    },
    ...legacy_api()
  };
  var div = root();
  var event_handler = (e) => {
    var _a;
    onScroll(e);
    (_a = $$props.onscroll) == null ? void 0 : _a.call($$props, e);
  };
  attribute_effect(div, () => ({
    onscroll: event_handler,
    ...rest,
    [STYLE]: {
      position: "relative",
      overflow: "auto",
      height: `${$$props.height ?? ""}px`,
      width: width()
    }
  }));
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var div_1 = root_1();
      var node_1 = child(div_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.header), "render", Grid, 156, 3);
      reset(div_1);
      bind_element_size(div_1, "offsetHeight", ($$value) => set(headerHeight, $$value));
      append($$anchor2, div_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.header) $$render(consequent);
      }),
      "if",
      Grid,
      154,
      1
    );
  }
  var div_2 = sibling(node, 2);
  let styles;
  validate_each_keys(() => get(indices), (index) => getKey()(index));
  add_svelte_meta(
    () => each(div_2, 21, () => get(indices), (index) => getKey()(index), ($$anchor2, index) => {
      const computed_const = tag(
        user_derived(() => {
          const { rowIndex, columnIndex, style } = getItemProps(get(index));
          return { rowIndex, columnIndex, style };
        }),
        "[@const]"
      );
      get(computed_const);
      var fragment = comment();
      var node_2 = first_child(fragment);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_3 = first_child(fragment_1);
          add_svelte_meta(
            () => snippet(node_3, () => $$props.item, () => ({
              index: get(index),
              rowIndex: get(computed_const).rowIndex,
              columnIndex: get(computed_const).columnIndex,
              style: get(computed_const).style
            })),
            "render",
            Grid,
            165,
            4
          );
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var fragment_2 = comment();
          var node_4 = first_child(fragment_2);
          add_svelte_meta(
            () => snippet(node_4, () => $$props.placeholder, () => ({
              index: get(index),
              rowIndex: get(computed_const).rowIndex,
              columnIndex: get(computed_const).columnIndex,
              style: get(computed_const).style
            })),
            "render",
            Grid,
            167,
            4
          );
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (!get(isScrollingFast) || !$$props.placeholder) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Grid,
          164,
          3
        );
      }
      append($$anchor2, fragment);
    }),
    "each",
    Grid,
    161,
    2
  );
  reset(div_2);
  var node_5 = sibling(div_2, 2);
  add_svelte_meta(() => snippet(node_5, () => $$props.footer ?? noop), "render", Grid, 172, 1);
  reset(div);
  bind_this(div, ($$value) => set(grid, $$value), () => get(grid));
  template_effect(() => styles = set_style(div_2, "", styles, { height: `${get(innerHeight) ?? ""}px`, width: "100%" }));
  bind_element_size(div, "offsetWidth", ($$value) => set(offsetWidth, $$value));
  bind_element_size(div, "clientWidth", ($$value) => set(clientWidth, $$value));
  append($$anchor, div);
  return pop($$exports);
}

// node_modules/svelte-virtual/dist/list/List.svelte
List[FILENAME] = "node_modules/svelte-virtual/dist/list/List.svelte";
var scrollStop3 = scrollStop();
var _scrollSpeed2 = scrollSpeed();
var root_2 = add_locations(from_html(`<div><!></div>`), List[FILENAME], [[172, 3]]);
var root_3 = add_locations(from_html(`<div><!></div>`), List[FILENAME], [[176, 3]]);
var root_5 = add_locations(from_html(`<div><!></div>`), List[FILENAME], [[190, 4]]);
var root_10 = add_locations(from_html(`<div><!></div>`), List[FILENAME], [[214, 3]]);
var root_11 = add_locations(from_html(`<div><!></div>`), List[FILENAME], [[218, 3]]);
var root2 = add_locations(from_html(`<div><!> <div><!> <!></div> <!></div>`), List[FILENAME], [[153, 0, [[182, 1]]]]);
function List($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, List);
  let height = prop($$props, "height", 3, "100%"), width = prop($$props, "width", 3, "100%"), stickyIndices = prop($$props, "stickyIndices", 19, () => []), overScan = prop($$props, "overScan", 3, 1), marginLeft = prop($$props, "marginLeft", 3, 0), marginTop = prop($$props, "marginTop", 3, 0), layout = prop($$props, "layout", 3, "vertical"), scrollPosition = prop($$props, "scrollPosition", 15, 0), scrollAlignment = prop($$props, "scrollAlignment", 3, "auto"), scrollBehavior = prop($$props, "scrollBehavior", 3, "auto"), getKey = prop($$props, "getKey", 3, (index) => index), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "itemCount",
      "itemSize",
      "height",
      "width",
      "stickyIndices",
      "overScan",
      "marginLeft",
      "marginTop",
      "layout",
      "scrollPosition",
      "scrollAlignment",
      "scrollBehavior",
      "getKey",
      "onscroll",
      "header",
      "item",
      "placeholder",
      "footer"
    ],
    "rest"
  );
  let list = tag(state(void 0), "list");
  let _scrollPosition = tag(state(proxy(scrollPosition())), "_scrollPosition");
  let headerHeight = tag(state(0), "headerHeight");
  let headerWidth = tag(state(0), "headerWidth");
  let offsetHeight = tag(state(0), "offsetHeight");
  let clientHeight = tag(state(0), "clientHeight");
  let offsetWidth = tag(state(0), "offsetWidth");
  let clientWidth = tag(state(0), "clientWidth");
  let indices = tag(state(proxy([])), "indices");
  let manualScroll = false;
  let isScrolling = false;
  let isScrollingFast = tag(state(false), "isScrollingFast");
  function scrollToIndex(index, alignment = scrollAlignment(), behavior = scrollBehavior()) {
    scrollTo(getScrollToPosition(index, alignment), behavior);
  }
  function scrollToPosition(position, behavior = scrollBehavior()) {
    scrollTo(position, behavior);
  }
  const getScrollToPosition = (index, alignment) => {
    const extra = get(isVertical) ? marginTop() + get(headerHeight) : marginLeft() + get(headerWidth);
    const maxOffset = index * $$props.itemSize + extra;
    const minOffset = maxOffset - get(size) + $$props.itemSize + extra;
    let offset;
    switch (alignment) {
      case "start":
        offset = maxOffset;
        break;
      case "center":
        offset = maxOffset - (get(size) - $$props.itemSize) / 2;
        break;
      case "end":
        offset = minOffset;
        break;
      default:
        offset = Math.max(minOffset, Math.min(maxOffset, scrollPosition()));
        break;
    }
    return Math.max(0, Math.min(get(innerSize) - get(size), offset));
  };
  const scrollTo = (direction, behavior = scrollBehavior()) => {
    if (get(list)) {
      manualScroll = true;
      get(list).scrollTo({ [get(isVertical) ? "top" : "left"]: direction, behavior });
      manualScroll = false;
    }
  };
  const scrollToManual = (scrollPosition2) => {
    if (get(list) && !manualScroll && !isScrolling) {
      manualScroll = true;
      get(list).scrollTo({ top: scrollPosition2, behavior: scrollBehavior() });
      manualScroll = false;
    }
  };
  const getItemStyle = (index) => {
    const ixis = index * $$props.itemSize;
    return `position: absolute; transform: translate3d(${get(isVertical) ? `${marginLeft()}px, ${ixis + marginTop()}px` : `${get(headerWidth) + ixis + marginLeft()}px, ${marginTop()}px`}, 0px); ${get(itemSizeInternal)} will-change: transform;`;
  };
  const onScroll = (event) => {
    isScrolling = true;
    if (!manualScroll) {
      if (get(isVertical)) {
        set(_scrollPosition, Math.max(0, event.currentTarget["scrollTop"] - get(headerHeight)), true);
        scrollPosition(event.currentTarget["scrollTop"]);
      } else {
        set(_scrollPosition, Math.max(0, event.currentTarget["scrollLeft"] - get(headerWidth)), true);
        scrollPosition(event.currentTarget["scrollLeft"]);
      }
      get(scrollSpeed2)(get(_scrollPosition));
    }
    scrollStop3(() => {
      isScrolling = false;
    });
  };
  let isVertical = tag(user_derived(() => strict_equals(layout(), "vertical")), "isVertical");
  let innerSize = tag(user_derived(() => $$props.itemCount * $$props.itemSize), "innerSize");
  let itemSizeInternal = tag(
    user_derived(() => get(isVertical) ? `height: ${$$props.itemSize}px; width: ${marginLeft() > 0 ? `${get(clientWidth) - marginLeft()}px` : "100%"};` : `height: ${marginTop() > 0 ? `${get(clientHeight) - marginTop()}px` : "100%"}; width: ${$$props.itemSize}px;`),
    "itemSizeInternal"
  );
  let size = tag(user_derived(() => get(isVertical) ? get(offsetHeight) : get(offsetWidth)), "size");
  user_effect(() => {
    if (get(size)) {
      set(indices, getListIndices($$props.itemCount, $$props.itemSize, get(size), overScan(), get(_scrollPosition)), true);
    }
  });
  user_effect(() => {
    if (get(list)) {
      scrollToManual(scrollPosition());
    }
  });
  let scrollSpeed2 = tag(
    user_derived(() => _scrollSpeed2(get(size), {
      fast: () => {
        set(isScrollingFast, true);
      },
      slow: () => {
        set(isScrollingFast, false);
      }
    })),
    "scrollSpeed"
  );
  var $$exports = {
    get scrollToIndex() {
      return scrollToIndex;
    },
    get scrollToPosition() {
      return scrollToPosition;
    },
    ...legacy_api()
  };
  var div = root2();
  var event_handler = (e) => {
    var _a;
    onScroll(e);
    (_a = $$props.onscroll) == null ? void 0 : _a.call($$props, e);
  };
  attribute_effect(div, () => ({
    onscroll: event_handler,
    ...rest,
    [STYLE]: {
      position: "relative",
      overflow: "auto",
      height: strict_equals(typeof height(), "number") ? `${height()}px` : height(),
      width: strict_equals(typeof width(), "number", false) ? width() : `${width()}px`
    }
  }));
  var node = child(div);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        var consequent = ($$anchor3) => {
          var div_1 = root_2();
          var node_2 = child(div_1);
          add_svelte_meta(() => snippet(node_2, () => $$props.header), "render", List, 173, 4);
          reset(div_1);
          bind_element_size(div_1, "offsetHeight", ($$value) => set(headerHeight, $$value));
          append($$anchor3, div_1);
        };
        var alternate = ($$anchor3) => {
          var div_2 = root_3();
          set_style(div_2, "", {}, { position: "absolute" });
          var node_3 = child(div_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.header), "render", List, 177, 4);
          reset(div_2);
          bind_element_size(div_2, "offsetWidth", ($$value) => set(headerWidth, $$value));
          append($$anchor3, div_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (get(isVertical)) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          List,
          171,
          2
        );
      }
      append($$anchor2, fragment);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.header) $$render(consequent_1);
      }),
      "if",
      List,
      170,
      1
    );
  }
  var div_3 = sibling(node, 2);
  let styles;
  var node_4 = child(div_3);
  {
    var consequent_3 = ($$anchor2) => {
      const stickyIndex = tag(user_derived(() => Math.max(...stickyIndices().filter((i) => i < get(indices)[0]))), "stickyIndex");
      get(stickyIndex);
      var fragment_1 = comment();
      var node_5 = first_child(fragment_1);
      {
        var consequent_2 = ($$anchor3) => {
          var div_4 = root_5();
          let styles_1;
          var node_6 = child(div_4);
          add_svelte_meta(() => snippet(node_6, () => $$props.item, () => ({ index: get(stickyIndex), style: "" })), "render", List, 196, 5);
          reset(div_4);
          template_effect(() => styles_1 = set_style(div_4, "", styles_1, {
            position: "sticky",
            top: get(isVertical) ? `${marginTop()}px` : "0px",
            left: get(isVertical) ? "0px" : `${marginLeft()}px`,
            "z-index": "1"
          }));
          append($$anchor3, div_4);
        };
        add_svelte_meta(
          () => if_block(node_5, ($$render) => {
            if (get(stickyIndex) >= 0) $$render(consequent_2);
          }),
          "if",
          List,
          189,
          3
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node_4, ($$render) => {
        if (stickyIndices().length && get(indices).length) $$render(consequent_3);
      }),
      "if",
      List,
      186,
      2
    );
  }
  var node_7 = sibling(node_4, 2);
  validate_each_keys(() => get(indices), (index) => getKey()(index));
  add_svelte_meta(
    () => each(node_7, 17, () => get(indices), (index) => getKey()(index), ($$anchor2, index) => {
      const style = tag(user_derived(() => getItemStyle(get(index))), "style");
      get(style);
      var fragment_2 = comment();
      var node_8 = first_child(fragment_2);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_9 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_9, () => $$props.item, () => ({ index: get(index), style: get(style) })), "render", List, 205, 4);
          append($$anchor3, fragment_3);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_10 = first_child(fragment_4);
          add_svelte_meta(() => snippet(node_10, () => $$props.placeholder, () => ({ index: get(index), style: get(style) })), "render", List, 207, 4);
          append($$anchor3, fragment_4);
        };
        add_svelte_meta(
          () => if_block(node_8, ($$render) => {
            if (!get(isScrollingFast) || !$$props.placeholder) $$render(consequent_4);
            else $$render(alternate_1, false);
          }),
          "if",
          List,
          204,
          3
        );
      }
      append($$anchor2, fragment_2);
    }),
    "each",
    List,
    201,
    2
  );
  reset(div_3);
  var node_11 = sibling(div_3, 2);
  {
    var consequent_6 = ($$anchor2) => {
      var fragment_5 = comment();
      var node_12 = first_child(fragment_5);
      {
        var consequent_5 = ($$anchor3) => {
          var div_5 = root_10();
          var node_13 = child(div_5);
          add_svelte_meta(() => snippet(node_13, () => $$props.footer), "render", List, 215, 4);
          reset(div_5);
          append($$anchor3, div_5);
        };
        var alternate_2 = ($$anchor3) => {
          var div_6 = root_11();
          let styles_2;
          var node_14 = child(div_6);
          add_svelte_meta(() => snippet(node_14, () => $$props.footer), "render", List, 223, 4);
          reset(div_6);
          template_effect(() => styles_2 = set_style(div_6, "", styles_2, {
            position: "absolute",
            top: "0px",
            left: `${get(headerWidth) + $$props.itemCount * $$props.itemSize + marginLeft()}px`
          }));
          append($$anchor3, div_6);
        };
        add_svelte_meta(
          () => if_block(node_12, ($$render) => {
            if (get(isVertical)) $$render(consequent_5);
            else $$render(alternate_2, false);
          }),
          "if",
          List,
          213,
          2
        );
      }
      append($$anchor2, fragment_5);
    };
    add_svelte_meta(
      () => if_block(node_11, ($$render) => {
        if ($$props.footer) $$render(consequent_6);
      }),
      "if",
      List,
      212,
      1
    );
  }
  reset(div);
  bind_this(div, ($$value) => set(list, $$value), () => get(list));
  template_effect(() => styles = set_style(div_3, "", styles, {
    height: get(isVertical) ? `${get(innerSize)}px` : "100%",
    width: !get(isVertical) ? `${get(innerSize)}px` : "100%"
  }));
  bind_element_size(div, "offsetHeight", ($$value) => set(offsetHeight, $$value));
  bind_element_size(div, "clientHeight", ($$value) => set(clientHeight, $$value));
  bind_element_size(div, "offsetWidth", ($$value) => set(offsetWidth, $$value));
  bind_element_size(div, "clientWidth", ($$value) => set(clientWidth, $$value));
  append($$anchor, div);
  return pop($$exports);
}
export {
  Grid,
  List
};
//# sourceMappingURL=svelte-virtual.js.map
